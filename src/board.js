'use strict';

const Cell = require("./cell");

/**
 * Board class representing board of game (othello)
 *
 * @class
 */
class Board {

    /**
     * Board constructor
     *
     * @param {number} [width=8] - Width or spread of board
     */
    constructor(width = 8) {

        this.width = width;

        /*
         * All cells will store in an object with a key that generated by x,y coordinates of cell.
         * ex. cell with coordinates [1, 2] will has a key like "1-2".
         */
        this.cells = {};
        this.moves = [];
        this.turn = "black";
        this._finished = false;


        // initial the board
        this.initBoard();
    }

    /**
     * Getter for the finish status of the game.
     * This will return true if the game has been finished.
     *
     * @returns {boolean}
     */
    get finished() {
        return this._finished
    }

    /**
     * This method will init the board and place an instance of *Cell* in each cell
     *
     */
    initBoard() {
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.width; y++) {
                this.cells[`${x}-${y}`] = new Cell(x, y);
            }
        }

        // put first four nut on board
        this.putInitialNuts();
    }

    /**
     * Method will place four (4) init nuts on board.
     */
    putInitialNuts() {
        const centerCord = Math.floor(this.width / 2);

        this.setOwner(centerCord, centerCord, "white");
        this.setOwner(centerCord - 1, centerCord - 1, "white");

        this.setOwner(centerCord, centerCord - 1, "black");
        this.setOwner(centerCord - 1, centerCord, "black");

        this.findMoves();
    }

    /**
     * Get specific cell of the board by coordinates.
     *
     * @param x
     * @param y
     * @returns {*}
     */
    getCell(x, y) {
        return this.cells[`${x}-${y}`]
    }

    /**
     * Board has two player, white and black.
     * and `turn` property of the board shows the player on move.
     * So, this method will change the turn
     */
    changeTurn() {
        this.turn = this.turn === "white" ? "black" : "white";
    }

    /**
     * Set owner of specific cell if the cell is exists.
     *
     * @param {number} x
     * @param {number} y
     * @param {string|null} owner
     */
    setOwner(x, y, owner) {
        if (!this.getCell(x, y)) {
            throw new Error(`Could not found any cell for x:${x} & y:${y}`)
        }

        this.getCell(x, y).owner = owner;
    }

    /**
     * Return all nuts that places on the board.
     *
     * @param {string|null} owner - To specify the owner of the cells that wanted.
     * @returns {Array}
     */
    getNuts(owner = null) {
        let nuts = [];
        Object.keys(this.cells)
            .map(key => {
                if ((!owner && this.cells[key].owner !== null) || (owner && this.cells[key].owner === owner))
                    nuts.push(this.cells[key]);
            });
        return nuts;
    }

    /**
     * Return all white nuts that places on the board.
     *
     * @returns {Array}
     */
    getWhiteNuts() {
        return this.getNuts("white");
    }

    /**
     * Return all black nuts that places on the board.
     *
     * @returns {Array}
     */
    getBlackNuts() {
        return this.getNuts("black");
    }

    /**
     * Add a cell as valid move for a player and his nuts
     *
     * @param {number} x - Cell x coordinates
     * @param {number} y - Cell y coordinates
     * @param {array} centerNut - To specify that which nut has responsible for the move
     * @param {string} direction - To specify the cross direction that find this move
     * @param relatedCells
     */
    addMove(x, y, centerNut, direction, relatedCells) {

        let alreadyAdded = false;
        this.moves.map((move) => {
            if (move.x === x && move.y === y) {
                alreadyAdded = true;

                if (move.directions.indexOf(direction) === -1) {
                    move.directions.push(direction);
                    move.relatedCells = [...move.relatedCells, ...relatedCells]
                }
            }
        });

        if (!alreadyAdded)
            this.moves.push({
                x,
                y,
                centerNut,
                relatedCells,
                directions: [direction],
            })
    }

    /**
     * Check if a coordinate is on board or not
     *
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    isOnBoard(x, y) {
        return (x > -1 && y > -1) && (x < this.width && y < this.width)
    }

    /**
     * Get coordinate of empty neighbors of a cell
     *
     * @param {number} x
     * @param {number} y
     * @returns {Array}
     */
    getEmptyNeighborsOfCell(x, y) {
        let emptyNeighbors = [];

        const cellNeighbors = this.getCell(x, y).neighbors();
        cellNeighbors.map(([nx, ny]) => {
            if (this.isOnBoard(nx, ny) && this.getCell(nx, ny).owner === null) {
                emptyNeighbors.push(this.getCell(nx, ny));
            }
        });

        return emptyNeighbors
    }

    /**
     * Find all possible moves of the board for *current turn*
     */
    findMoves() {

        this.moves = [];

        let nuts;
        let rival = "white";
        if (this.turn === "white") {
            nuts = this.getBlackNuts();
            rival = "black"
        } else {
            nuts = this.getWhiteNuts();
        }


        for (let nut of nuts) {

            const [nutX, nutY] = nut.pos();
            const neighbors = this.getEmptyNeighborsOfCell(nutX, nutY);

            neighbors.forEach(neighbor => {
                const [x, y] = neighbor.pos();

                for (let {direction, coordinates} of this.neighborsOfNutsCalculator()) {
                    const [nx, ny] = coordinates;
                    let tmpX = x + nx;
                    let tmpY = y + ny;

                    let currentCell = this.getCell(tmpX, tmpY);

                    if (
                        !this.isOnBoard(tmpX, tmpY) ||
                        currentCell.owner === null ||
                        currentCell.owner === this.turn
                    ) {
                        continue;
                    }

                    while (this.getCell(tmpX, tmpY).owner === rival) {
                        tmpX += nx;
                        tmpY += ny;
                    }

                    if (this.getCell(tmpX, tmpY).owner === this.turn) {
                        let relatedCells = [];
                        while (true) {
                            if (tmpX === x && tmpY === y)
                                break;

                            tmpX -= nx;
                            tmpY -= ny;

                            relatedCells.push([tmpX, tmpY])

                        }
                        this.addMove(x, y, [nutX, nutY], direction, relatedCells)
                    }
                }
            })
        }

    }

    /**
     * Check move validity for a coordinate
     *
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    isValidMove(x, y) {
        return this.moves.find(move => move.x === x && move.y === y) !== undefined
    }

    /**
     * This method call when player wants to place nut on a cell.
     *
     * @param {number} x
     * @param {number} y
     */
    placeNutTo(x, y) {

        if (!this.isValidMove(x, y))
            throw new Error(`The move [${x},${y}] is impossible!`);

        const move = this.moves.find(move => move.x === x && move.y === y);

        // flip nuts of all directions together
        move.relatedCells.map(([x, y]) => this.getCell(x, y).owner = this.turn);

        // change turn after each placement
        this.changeTurn();
        this.findMoves();

        // check valid moves after each placement
        // and change the turn again when moves are empty
        if (this.moves.length === 0) {
            this.changeTurn();
            this.findMoves();

            // check the moves length again and set the finish status as true if it is empty
            if (this.moves.length === 0)
                this._finished = true;
        }

    }

    /**
     * This will return a result for board as object.
     *
     * @returns {{winner: string, white: number, black: number}}
     */
    gameResult() {
        const white = this.getWhiteNuts().length,
            black = this.getBlackNuts().length;

        return {
            white,
            black,
            winner: white > black ? "white" :
                black > white ?
                    "black" : "equal"
        };

    }

    /**
     * Get all neighbors as coordinates. all coordinates specify a direction to nut
     * and should add to nut coordinates to emulate direction
     * @returns {*[]}
     */
    neighborsOfNutsCalculator() {
        return [
            {
                direction: "topLeftToNut",
                coordinates: [1, 1],
            },
            {
                direction: "topCenterToNut",
                coordinates: [0, 1],
            },
            {
                direction: "topRightToNut",
                coordinates: [-1, 1]
            },
            {
                direction: "centerLeftToNut",
                coordinates: [1, 0],
            },
            {
                direction: "centerRightToNut",
                coordinates: [-1, 0],
            },
            {
                direction: "bottomLeftToNut",
                coordinates: [1, -1],
            },
            {
                direction: "bottomCenterToNut",
                coordinates: [0, -1],
            },
            {
                direction: "bottomRightToNut",
                coordinates: [-1, -1],
            }];
    }
}

module.exports = Board;